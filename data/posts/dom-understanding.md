다른 Main 으로 시작해서 Main이 끝나면 종료되는 프로그램과 다르게
자바스크립트 런터임 환경에서는 사용자가 프로그램을 종요하지 않는 이상
계속 실행되고 있는 상태이기 때문에 콜스택(Call Stack)이 비었다고 해서 프로그램이 종료되지 않음

- 큐 -> 콜스택 이동 방법
  이벤트 루프 이기 때문에 빙글빙글 순회하면서 가져온다고 설명했지만
  실제로는 Queue(큐)에 있는 것들을 Call Stack 으로 직접 이동해서 넣는 것이 아니라 단순히 API를 호출해서 해당하는 콜백함수를 Call Stack 으로 넣어주는 것 (Ex. 배열에서 push 라는 API라는 호출해서 데이터를 넣는 것처럼)
  이벤트 루프

#### 이밴트 루프

1초에 60 fps (16.7ms)

- fps(프레임) : 1초 동안 컴터에서 보내는 영상(장면)의 수.
- Hz(헤르츠/주사율) : 1초 동안 모니터를 통해 출력된 영상(장면)의 수. ex. 1초 동안 3개의 화면이 출력되었다면 3Hz
  1부터 120까지를 1초만에 출력하는 화면이 있다면 120fps의 성능을 내는 컴퓨터에서 출력을 쏘더라도 144Hz 모니터에서는 1부터 120까지 모든 숫자를 다 볼 수 있지만 60Hz 모니터에서는 홀수만 볼 수 있거나 짝수만 볼 수 있거나 그 중간만 볼수 있거나 한다고 합니다.

이벤트루프(event loop)는 한바퀴도는데 1ms 조차 걸리지 않습니다.
이벤트루프는 순회하다가 Call Stack 이 다 비어질 때까지 콜스택에 머물러있다가
(콜스택에서 무거운 연산등을 실행하면 업데이트를 할 수 없게 되는 현상이 발생)다 비어지면 다시 순회하고 업데이트가 필요해 질때(16.7ms 를 지키려고 함) Render Sequence(렌더시퀀스)에 가서 위에 그림 처럼 실행하여 업데이트합니다.

이후 또 무한히 순회하고 Microtask Queue(MQ)에 promise then, mutation observer(web api 중 한가지 이며 이 api 에 등록된 callback) 있다면 MQ 머무르면서 하나씩 Call Stack 으로 가져와서(내부적으로 위와 같이 큐 -> 콜스택 이동방법처럼 가져오기 때문에)실행하고 MQ가 비어져 있지 않다면 또 가져와서 실행하고 MQ가 다 비어질 때까지 이벤트 루프는 순회하지 않고 MQ가 다 비어질때까지 머무르면서 가져와서 실행되게 됩니다. MQ가 다 비어졌으면 다시 순회하고 순회하다가 Task Queue(TQ)에 callback 이 있다면 Call Stack 으로 하나를 가져와서 실행하고 루프를 순회하고 이후에 다시 와서 하나를 가져와서 실행하고 다시 루프를 순회합니다. 이런식으로 자바스크립트 런타임 환경이 동작하게 됩니다.

TQ 와 MQ 가 다른점

TQ에 있는 것들은 하나씩 가져와서 실행하고 루프를 순회해서 다시가져 오는데
MQ에 있는 것들은 하나씩 가져와서 실행하고 또 있으면 루프를 순회해서 가져오는 것이 아니라 머무르면서 하나씩 가져와서 MQ가 비어질때까지 실행 함)

> React에서의 상태 업데이트는 일반적으로 한 프레임 내에서 처리됩니다.
> React는 상태나 속성이 변경될 때 해당 컴포넌트를 다시 렌더링하고, 이 과정이 한 프레임 안에 처리됩니다.
> 간단한 상태 업데이트는 한 프레임 내 처리되지만 복잡한 렌더링 로직이나 연산이 많은 경우 한 프레임에 처리하기 어려울 수 있습니다.
> React는 내부적으로 상태 업데이트와 컴포넌트 렌더링을 효율적으로 처리하여 성능을 최적화하려고 노력 합니다.
> 이는 React의 가상 DOM 및 재조정 과정 통해 가능하며 변경된 부분만을 최소한으로 업데이트하여 효율적으로 렌더링을 구현합니다.
> 대부분의 경우 React에서의 상태 업데이트는 한 프레임 내에서 처리되며, 이러한 방식으로 빠르게 컴포넌트를 업데이트하고 화면을 갱신할 수 있습니다.

> 요약하면, 상태가 업데이트되면 리액트는 컴포넌트를 다시 렌더링하고 화면을 업데이트 하려고 합니다. 하지만 실제로 화면이 업데이트되는 시점은 브라우저의 다음 프레임을 그릴때 이며 이는 브라우저의 성능, 현재 시스템 부하 등에 따라 다를 수 있습니다. 컴포넌트의 렌더링이 60fps 안에 실행되는 것은 최적의 상황이지만 환경에 따라 다를 수 있습니다.
> React는 가능한 한 빠르게 렌더링을 처리하려고 노력할 것이지만 실제 렌더링 속도는 브라우저와 시스템의 성능에 의존합니다.
